# ZeOS game implementation notes

1. Keyboard support stores keys in a circular buffer.

Circular buffer (32B in size) with two pointers, read and write.

Keyboard interrupt routine writes a character (not scancode) in the write
pointer and increases it, wrapping around if surpassing the end.


Test
```
event_t e;
while(1) {
    if (poll_event(&e) == 0 && e.pressed) {
        write(1, &e.c, 1);
    }
}
```

The test requires user input (pressing keys)


2. Functional pollEvent feature.

pollEvent reads the character at the read pointer and increases it, if the read
pointer is not at the same position as the write pointer (empty buffer).

A problem we had was adding the syscall, for which we took the wrappers from our
own branch, because they were easier to work with; but the argument order
appears to be different in this branch than in the original one: %ebx and %edx
are swapped. This branch is more akin the Linux call convention.

I would like to add that the file structure of ZeOS, and where to put specific
pieces of code is rather unclear.

Test
*same code as previus, tests both functionalities.


3. Functional change cursor position feature.

We rewrote the terminal emulator at io.c to support the CSI 'H' ANSI escape
sequence.

Test
```
write(1, "\x1b[20;20H", 8);
write(1, "adios", 7);
```

Prints "adios" at position 20,20.


Invalid test
```
write(1, "\x1b[40;90H", 8);     /* no effect */
write(1, "adios", 7);
```

4. Functional remove character feature.

This is a special case of moving and writing (a space), so we decided against
providing an specific escape code, which also we couldn't find anywhere in ANSI.
(only clear part or full lines).

Test
```
write(1, "\x1b[20;20H", 8);
write(1, "akjsdaf", 7);
write(1, "\x1b[22;20H", 8);
write(1, " ", 5);
```

Removes the 'j' character.


5. Functional change foreground and background color features.

It was decided that the 3 and 4-bit color ANSI escape sequences were sufficient
for this game, so we did not need to complicate the ANSI parser further for
true color escapes.

Test
```
write(1, "\x1b[31m", 5);
write(1, "akjsdaf", 7);
write(1, "\x1b[44m\x1b[93m", 10);
write(1, "akjsdaf", 7);
```

Prints 'akjsdaf' in red, and the same again with blue background and yellow
foreground.


6. Functional clone and exit system calls.

We copied the functionality of fork(), but without allocating a new data segment
becase data is completely shared, given that the thread stack is inside the
parent thread stack. PCBs are copied 1:1.

exit() was also modified accordingly to destroy process resources only when
this is the last thread standing

Thread local errno was implemented as a macro for get_errno() syscall,
which is set in the wrappers with set_errno() syscall

We solved the directory allocation problem by dynamically allocating any
free directory by looking it up in the PCBs

Test 1
```
void keyboard_thread(void *);   // loop de teclado

char tstack[1024];
clone(&keyboard_thread, NULL, &tstack[1023]);

// otro loop de teclado
```

Test 2
```
void keyboard_thread(void *);   // loop de teclado

clone(&keyboard_thread, NULL, NULL);
``` retorna <0

Test 3
```
char tstack[1024];
clone(NULL, NULL, tstack);
``` retorna <0

Test 4
```
[en thread]
write(1, "a", 1);
printf("%d", errno);
```

Test 5
```
[en main]
fork();

char tstack[1024];
clone(&keyboard_thread, NULL, &tstack[1023]);
```


7. 

Functional synchronization support.

Test 1
```
[
```


8. Functional getSlot and delSlot features.

We chose to implement a very simple allocator that actually supports
freeing slots.

We have a vector of fixed size per thread, that stores what allocations are
currently in the present thread (up to 10). The get_slot() syscall places the
slot after the highest currently allocated page, so that we may not have to
think about putting allocations in holes between allocations. del_slot() simply
clears the allocation in the slot vector and unmaps the pages appropiately.

access_ok() was modified to account for allocations outside initial user data 
segment.

And lastly so, fork() was modified to account for allocating and copying parent
slots.

Test 1
```
char *slot = get_slot(1024*1024);
for (DWord i = 0; i < 1024*1024; i += 1024) {
    slot[i] = 'a';
    write(1, &slot[i], 1);
}
del_slot(slot);
slot[0] = 0;
```

Test 2
```
del_slot(NULL);
``` retorna <0


9. Functional game using different implemented features.



## TODO

 - [A] 1. (1 point)   Keyboard support stores keys in a circular buffer.
 - [A] 2. (1 point)   Functional pollEvent feature.
 - [A] 3. (.5 points) Functional change cursor position feature.
 - [A] 4. (.5 points) Functional remove character feature.
 - [A] 5. (1 point)   Functional change foreground and background color features.
 - [X] 6. (2 points)  Functional clone and exit system calls.
 - [X] 7. (2 point)   Functional synchronization support.
 - [X] 8. (1 points)  Functional getSlot and delSlot features.
 - [X] 9. (1 point)   Functional game using different implemented features.
 - [ ] 10. [Optional] (1 point) Challenge: Implement a user level slab allocator on top of ‘getSlot’.

### improvements

 - [X] poll event -> scancodes
 - [X] no machacar scancodes nuevos
 - [X] comprobar parametros de poll event
   - [X] y de clone
 - [X] thread exit
 - [X] Check n and m bounds.

 - [X] no hay thread exit, exit tiene que terminar un thread, y si es el ultimo, liberar recursos (directorio)
 - [X] gestion de directorio: fork() puede coger la PCB de un thread
 - [X] thread local errno
 
 - [X] desbloquear threads cuando se destruye un semaforo (con return especifico)
 - [X] solo puede destruir el semaforo el thread que lo ha creado
 - [X] exit libera semaforos

 - [X] exit libera slots

